#### static
   - static:静态的，可以用来修饰属性、方法、代码块（或初始化块）、内部类
   - static修饰属性
      - 由类创建的所有的对象，都共用这一个属性
      - 当其中一个对象对此属性进行修改，会导致其他对象对此属性的一个调用。vs 实例变量（非static修饰的属性，各个对象各自拥有一套副本）
      - 类变量随着类的加载而加载的，而且独一份
      - 静态的变量可以直接通过“类.类变量”的形式来调用
      - 类变量的加载是要早于对象。所以当有对象以后，可以“对象.类变量”使用。但是"类.实例变量"是不行的。
      - 类变量存在于静态域中。
   - static修饰方法
      - 随着类的加载而加载，在内存中也是独一份
      - 可以直接通过“类.类方法”的方式调用
      - 内部可以调用静态的属性或静态的方法，而不能调用非静态的属性或方法。反之，非静态的方法是可以调用静态的属性或静态的方法
      - 静态的方法内是不可以有this或super关键字的！
      - 注：静态的结构(static的属性、方法、代码块、内部类)的生命周期要早于非静态的结构，同时被回收也要晚于非静态的结构
#### 单例模式
   - 解决的问题：如何只让设计的类只能创建一个对象
   ```java
   class Bank{
   	//1.私有化构造器
   	private Bank(){}
   	//2.创建类的对象，同时设置为private的，通过公共的来调用，体现封装性
   	//4.要求此对象也为static的
   	private static Bank instance = new Bank();
   	//3.此公共的方法，必须为static 
   	public static Bank getInstance(){
   		return instance;	
   	}
   }
   
   //饿汉式2
   class Bank{
   	//1.私有化构造器
   	private Bank(){}
   	//2.创建类的对象，同时设置为private的，通过公共的来调用，体现封装性
   	//4.要求此对象也为static的
   	private static Bank instance = null;
   	static{
   		instance  = new Bank();	
   	}
   	//3.此公共的方法，必须为static 
   	public static Bank getInstance(){
   		return instance;	
   	}
   }
   
   //懒汉式
   class Bank{
   	private Bank(){}
   	
   	private static Bank instance = null;
   	
   	public static Bank getInstance(){
   		if(instance == null){//可能存在线程安全问题的！
   			instance = new Bank();		
   		}	
   		return instance;
   	}
   }
   ```
#### main方法
```java
public static void main(String[] args){
     //方法体     
}

//1.main()是一个方法，是主方法，为程序的入口
//2.权限修饰符：public protected 缺省 private ---面向对象的封装性
//3.对于方法来讲：static final abstract 
//4.方法的返回值：void /  具体的返回值类型（基本的数据类型 & 引用数据类型），方法内部一定要有return
//5.方法名：命名的规则：xxxYyyZzz。给方法命名时，要见名之意
//6.形参列表：同一个方法名不同的形参列表的诸多个方法间构成重载。   形参 & 实参---方法的参数传递机制：值传递
//7.方法体：方法定义的是一种功能，具体的实现由方法体操作。
```
#### 代码块
   - 作用：用来初始化类的属性
   - 分类：只能用static来修饰。
   - 静态代码块：
      - 里面可以有输出语句
      - 随着类的加载而加载，而且只被加载一次
      - 多个静态代码块之间按照顺序结构执行
      - 静态代码块的执行要早于非静态代码块的执行。
      - 静态的代码块中只能执行静态的结构(类属性，类方法)
    
   - 非静态代码块：
      - 可以对类的属性(静态的 & 非静态的)进行初始化操作，同时也可以调用本类声明的方法(静态的 & 非静态的)
      - 里面可以有输出语句
      - 一个类中可以有多个非静态的代码块，多个代码块之间按照顺序结构执行
      - 每创建一个类的对象，非静态代码块就加载一次。
      - 非静态代码块的执行要早于构造器
     
   - 关于属性赋值的操作：
      - 默认的初始化
      - 显式的初始化或代码块初始化(此处两个结构按照顺序执行) 
      - 构造器中；
      - 通过方法对对象的相应属性进行修改
#### final
   - final:最终的 ，可以用来修饰类、属性、方法
   - final修饰类：这个类就不能被继承。如：String类、StringBuffer类、System类
   - final修饰方法：不能被重写。如：Object类的getClass()
   - final修饰属性：此属性就是一个常量，一旦初始化后，不可再被赋值。习惯上，常量用大写字符表示。
   - 此常量在哪里赋值：①此常量不能使用默认初始化 ②可以显式的赋值、代码块、构造器。
   - 变量用static final修饰：全局常量。比如：Math 类的PI
   - 与finally finalize()区分开
#### abstract
   - abstract：抽象的，可以用来修饰类、方法
   - abstract修饰类：抽象类
      - 不可被实例化
      - 抽象类有构造器 (凡是类都有构造器)
      - 抽象方法所在的类，一定是抽象类。
      - 抽象类中可以没有抽象方法。
      - 当我们设计一个类，不需要创建此类的实例时候，就可以考虑将其设置为抽象的，由其子类实现这个类的抽象方法以后，就行实例化
     
   - abstract修饰方法：抽象方法
      - 格式：没有方法体，包括{}.如：`public abstract void eat();`
      - 抽象方法只保留方法的功能，而具体的执行，交给继承抽象类的子类，由子类重写此抽象方法。
      - 若子类继承抽象类，并重写了所有的抽象方法，则此类是一个"实体类",即可以实例化
      - 若子类继承抽象类，没有重写所有的抽象方法，意味着此类中仍有抽象方法，则此类必须声明为抽象的！
#### 接口
   - 接口（interface）  是与类并行的一个概念
   - 接口可以看做是一个特殊的抽象类。是常量与抽象方法的一个集合，不能包含变量、一般的方法。
   - 接口是没有构造器
   - 接口定义的就是一种功能。此功能可以被类所实现（implements）。比如：`class CC extends DD implements AA`
   - 实现接口的类，必须要重写其中的所有的抽象方法，方可实例化。若没有重写所有的抽象方法，则此类仍为一个抽象类
   - 类可以实现多个接口。----java 中的类的继承是单继承的
   - 接口与接口之间也是继承的关系，而且可以实现多继承
   - 接口与具体的实现类之间也存在多态性
#### 内部类
   - 相当于说，我们可以在类的内部再定义类。外面的类：外部类。里面定义的类：内部类
   - 内部类的分类：成员内部类（声明在类内部且方法外的）  vs 局部内部类(声明在类的方法里)
      - 成员内部类：
         - 是外部类的一个成员：①可以有修饰符（4个）②static final ③可以调用外部类的属性、方法
         - 具体类的特点：①abstract ②还可以在其内部定义属性、方法、构造器
      - 局部内部类：
   
  - 关于内部类，大家掌握三点：
     - 如何创建成员内部类的对象（如：创建Bird类和Dog类的对象）
     - 如何区分调用外部类、内部类的变量(尤其是变量重名时)
     - 局部内部类的使用 （见TestInnerClass1.java）      