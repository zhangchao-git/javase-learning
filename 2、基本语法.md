#### 变量
   - 基本数据类型：
      - 整型：byte（8 bit）、short、int（默认类型）、long
      - 浮点型：float、double (默认类型)
      - 字符型：char
      - 布尔类型： boolean（只能取值为true 或false，不能取null）
      - 补充：按照在类中存在的位置的不同：成员变量 vs 局部变量
   - 引用数据类型
      - 数组 
      - 类 
      - 接口
#### 进制（了解）
   - 十进制、二进制、八进制、十六进制
   - 二进制：计算机底层都是用二进制来存储、运算。
   - 二进制 与十进制之间的转换。
   - 二进制在底层存储：正数、负数都是以补码的形式存储的。（原码、反码、补码）
   - 四种进制间的转换
#### 变量的运算
   1. 自动类型转换：容量小的数据类型自动转换为容量大的数据类型
      ```java
       short s = 12;
       int i = s + 2;
       //注意：byte  short char之间做运算，结果为int型！
      ```
   2. 强制类型转换：是自动类型转换的逆向过程使用"()"实现强转
#### 运算符
   - 运算符是一种特殊的符号，用以表示数据的运算、赋值和比较等。
   1. 算术运算符
      ```java
      +  -  + - * / % ++ -- +
      ```
      - /:   int i = 12;  i = i / 5;
      - %：最后的符号只跟被模数相同
      - 前++：先+1，后运算。后++：先运算，后+1
      - +：String字符串与其他数据类型只能做连接运算，且结果为String类型。
   2. 赋值运算符
      ```java
      =    +=   -=  *=    /=   %=
      int i= 12；
      i  = i * 5;
      i *= 5;//与上一行代码同样的意思
      //【特别地】
      short s = 10;
      s = s + 5;//报编译的异常
      s = (short)(s + 5);
      s += 5;//s = s + 5，但是结果不会改变s的数据类型。
      ```
   3. 比较运算符（关系运算符）
      ```java
      ==  >   <  >=   <=    instanceof  
      ```
      - 区分==  与 =  区别。
      - 进行比较运算操作以后，返回一个boolean类型的值
      4>=3  表达的是4 > 3或者 4 = 3.结果是true。
   4. 逻辑运算符（运算符的两端是boolean值）
      ```java
      &   &&  |  ||  ^ !
      ```
      - 区分 &  与 && 的区别，以及 |  与 || 的区别
        我们使用的时候，选择&& ， ||
   5. 位运算符(两端是数值类型的数据)
      ```java
      <<   >>    >>>  &  |   ^  ~
      ```
   6. 三元运算符
      - (条件表达式)? 表达式1 : 表达式2;
      - 既然是运算符，一定会返回一个结果，并且结果的数据类型与表达式1，2的类型一致
      - 表达式1与表达式2 的数据类型一致。
      - 使用三元运算符的，一定可以转换为if-else。反之不一定成立。
      例子：获取两个数的较大值；获取三个数的最大值。
#### 流程控制
   1. 顺序结构
      - 程序从上往下的顺序执行

   2. 分支结构：
      1. 条件判断
          ```java
          if(条件表达式){   }
    
          if(条件表达式){
          //执行的语句1；
          }else{
          //执行的语句2；
          }
    
          if(条件表达式1){
          //执行的语句1；
          }else if(条件表达式2){
          //执行的语句2；
          }else if( 条件表达式3){
          //执行的语句3；
          }
          ...
          }else{
          //执行的语句；
          }
          ```
          - 一旦满足某个条件表达式，则进入其执行语句块执行，执行完毕，跳出当前的条件判断结构，不会执行其以下的条件结构语句。
          - 如果诸多个条件表达式之间为“互斥”关系，多个结构可以上下调换顺序
          - 如果诸多个条件表达式之间为“包含”关系，要求条件表达式范围小的写在范围大的上面。
      2. 选择结构
         ```java
         switch(变量){
            case 值1:
            
            //break;
            case 值2:
            
            //break;
            ...
            default:
            
            break;
         }

         ```
         - 变量可以为如下的数据类型：byte、short、int、char、枚举、String 
         - case后只能填写变量的值，不能写范围。
         - default是可以省略的。并且其位置也是灵活的，但是通常将其放在case语句之后。
         - 一旦满足某个case语句，则进入执行其操作。直至遇到break或者程序终止。
         - 若要判断的语句的条件满足switch变量的数据类型，且值不多的情况下，建议选择switch-case .
           除此之外，选择if-else.
   3. 循环结构
      ```java
      ①初始化条件
      ②循环条件
      ③迭代部分
      ④循环体
        
      for(①;②;③){      
        ④
      }
        
      ①
      while(②){      
        ④
        ③
      }
        
      ①
      do{      
        ④
        ③
      }while(②);
      ```
      - 不同的循环结构之间可以相互转换
      - while和do-while的区别：do-while程序至少会执行一次
      - 嵌套循环：循环结构还可以声明循环。让内层循环结构整体充当外层循环的循环体。
       若外层循环执行m次，内层循环执行n次，整个程序执行m*n次。外层循环控制行数，内层循环控制列数
       ```java
        for(int i = 0;i < 3;i++){
            for(int j = 0;j < 6;j++){
                System.out.print("*");
            }
            System.out.println();
        }
       ```
      - 无限循环结构
      ```java
        for(;;){
           ...
           if(  ){
            break;
           }
           ...
        }
        或者
        while(true){
           ...
           if(  ){
            break;
           }
           ...
        }
      ```
      - 往往我们在无限循环结构内部提供循环的终止条件，使用break关键字。否则，此循环将无限制的执行下去，形成死循环！
        死循环是我们要避免的。
   4. break & continue
      - break:在循环结构中，一旦执行到break，就跳出当前循环。  
      - continue:在循环结构中，一旦执行到continue，就跳出当次循环。
      ```java
        for(int i = 1;i <= 10;i++){
            if(i % 4 == 0){
                //break; //123
                continue;  //123567910
            }
            System.out.print(i);
        }
        
        
        //在嵌套循环中，使用带标签的break和continue。
        label:for(int i = 1;i < 5;i++){
            for(int j = 1;j <= 10;j++){
                if(j % 4 == 0){
                    //break;
                    //continue;
                    //break label;
                    continue label;
                }
                System.out.print(j);
            }
            System.out.println();
        }
      ```
#### 数组
   - 数组：相同数据类型的数据的组合。
   1. 数组的初始化
      ```java
        //一维数组初始化
        int[] scores1 = new int[]{72,90,59};//静态初始化：在声明并初始化数组与给数组相应的元素赋值操作同时进行。
        int scores2[] = new int[3];//动态初始化：在声明并初始化数组与给数组相应的元素赋值操作分开进行。
        scores2[0] = 72;
        scores2[1] = 90;
        scores2[2] = 59;
        //声明数组的错误写法：
        String[] names = new String[5]{"AA","BB","CC"};
        int i[10];
        int i = new int[];
  
        //二维数组初始化
        String[][] str = new String[4][3]; //4行3列
        String[][] str1 = new String[4][];
        str1[0] = new String[3];
        ...
        str1[3] = new String[5];
        int[][] arr = new int[][]{{1,2,3},{4,5},{6}};
        //引用二维数组
        arr[1][0] = 12;
        arr.length;//3
        
      ```
      - 不管是动态还是静态初始化数组，一定在创建的时候，就指明了数组的长度！
      - 如何引用数组元素：通过数组的下角标的方式。下角标从0开始，到n-1结束。其中n为数组的长度。
      - 数组的长度：通过数组的属性length来调用。
   2. 关于数组元素的默认初始化值
      - byte、short、int、long 默认：0
      - float、double 默认：0.0
      - char默认：空格
      - boolean默认：false
      - 引用类型变量默认:null
   3. 内存结构
   
      ![内存基本结构](https://raw.githubusercontent.com/zhangchao-git/javase-learning/master/images/%E5%86%85%E5%AD%98%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84.bmp)
      
      ![数组内存结构](https://raw.githubusercontent.com/zhangchao-git/javase-learning/master/images/%E6%95%B0%E7%BB%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.bmp)
   4. 数组排序
      - 插入排序
         1. 直接插入排序
         2. 折半插入排序
         3. Shell排序
      - 交换排序
         1. 冒泡排序
         2. 快速排序（或分区交换排序）  
      - 选择排序
        1. 简单选择排序
        2. 堆排序   
      - 归并排序
      - 基数排序
      - 还可以调用：Arrays工具类：Arrays.sort(arr);