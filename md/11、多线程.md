#### 创建java程序的线程（重点）
   - 继承于Thread类
   - 实现Runnable接口
#### 两种方式对比
   - 实现的方式较好。
      - 解决了单继承的局限性。
      - 如果多个线程有共享数据的话，建议使用实现方式，同时，共享数据所在的类可以作为Runnable接口的实现类。
#### 线程常用方法
   - start()
   - run()
   - currentThread()  
   - getName()  
   - setName(String name) 
   - yield() 
   - join()  
   - sleep() 
   - isAlive() 
   - getPriority()  
   - setPriority(int i)
   - wait()  
   - notify() 
   - notifyAll()
#### 线程生命周期
![线程生命周期](https://raw.githubusercontent.com/zhangchao-git/javase-learning/master/images/%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.bmp)

#### 线程同步机制（重点、难点）
   - 前提：如果我们创建的多个线程，存在着共享数据，那么就有可能出现线程的安全问题：当其中一个线程操作共享数据时，还未操作完成，另外的线程就参与进来，导致对共享数据的操作出现问题。
   - 解决方式：要求一个线程操作共享数据时，只有当其完成操作完成共享数据，其它线程才有机会执行共享数据。
   - 同步代码块
      ```java
       synchronized(同步监视器){
	   //操作共享数据的代码
       }
      ```
      - 同步监视器：俗称锁，任何一个类的对象都可以才充当锁。要想保证线程的安全，必须要求所有的线程共用同一把锁！
      - 使用实现Runnable接口的方式创建多线程的话，同步代码块中的锁，可以考虑是this。如果使用继承Thread类的方式，慎用this!
      - 共享数据：多个线程需要共同操作的变量。   明确哪部分是操作共享数据的代码。
      
   - 同步方法：将操作共享数据的方法声明为synchronized
      - 比如：`public synchronized void show(){ //操作共享数据的代码}`
      - 对于非静态的方法而言，使用同步的话，默认锁为：this。如果使用在继承的方式实现多线程的话，慎用！
      - 对于静态的方法，如果使用同步，默认的锁为：当前类本身。以单例的懒汉式为例。 Class clazz = Singleton.class
   - 总结：释放锁:wait();不释放锁： sleep()   yield()  suspend() (过时，可能导致死锁)

#### 线程的问题
   - 如下的三个方法必须使用在同步代码块或同步方法中！
      - wait():当在同步中，执行到此方法，则此线程“等待”，直至其他线程执行notify()的方法，将其唤醒，唤醒后继续其wait()后的代码
      - notify()/notifyAll():在同步中，执行到此方法，则唤醒其他的某一个或所有的被wait的线程。