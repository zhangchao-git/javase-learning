#### 泛型
   - 对象实例化时不指定泛型，默认为：Object。
   - 泛型不同的引用不能相互赋值。
   - 加入集合中的对象类型必须与指定的泛型类型一致。
   - 静态方法中不能使用类的泛型。
   - 如果泛型类是一个接口或抽象类，则不可创建泛型类的对象。
   - 不能在catch中使用泛型
   - 从泛型类派生子类，泛型类型需具体化
   - 泛型与继承的关系
      - A类是B类的子类，G是带泛型声明的类或接口。那么`G<A>`不是`G<B>`的子类！
   - 通配符：?
      - A类是B类的子类，G是带泛型声明的类或接口。则`G<?>` 是`G<A>`、`G<B>`的父类！
      - 以`List<?>`为例，能读取其中的数据。因为不管存储的是什么类型的元素，其一定是Object类的或其子类的。
      - 以`List<?>`为例，不可以向其中写入数据。因为没有指明可以存放到其中的元素的类型！唯一例外的是：null
   - `List<? extends A>` :可以将List<A>的对象或`List<B>`的对象赋给`List<? extends A>`。其中B 是A的子类
   - `? super A`:可以将`List<A>`的对象或`List<B>`的对象赋给`List<? extends A>`。其中B 是A的父类
#### 枚举
   - 自定义枚举类
      - 第一种方式
         - 私有化类的构造器，保证不能在类的外部创建其对象 
         - 在类的内部创建枚举类的实例。声明为：public static final 
         - 若类有属性，那么属性声明为：private final 。此属性在构造器中赋值。
      - 第二种方式（使用enum关键字定义枚举类）
         - 其中常用的方法：values()  valueOf(String name);
         - 让类实现此接口，类的对象共享同一套接口的抽象方法的实现。
         - 让类的每一个对象都去实现接口的抽象方法，进而通过类的对象调用被重写的抽象方法时，执行的效果不同

#### 注解
   ```java
      Retention: SOURCE   CLASS  RUNTIME
      Target:
      Documented:javadoc
      Inherited
   ```